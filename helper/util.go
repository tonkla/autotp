package helper

import (
	"math"
	"strconv"
	"time"

	gonanoid "github.com/matoous/go-nanoid/v2"
	t "github.com/tonkla/autotp/types"
)

// Now13 returns a millisecond Unix timestamp
func Now13() int64 {
	return time.Now().UnixNano() / 1e6
}

// GenID returns a string of a millisecond Unix timestamp
func GenID() string {
	return strconv.FormatInt(Now13(), 10)
}

// RandomStr returns a random string, generated by NanoID
func RandomStr(size int) (string, error) {
	if size == 0 {
		size = 13
	}
	return gonanoid.Generate("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", size)
}

// CalcSLStop calculates a stop price of the stop loss price
func CalcSLStop(side string, sl float64, gap float64, digits int64) float64 {
	if gap == 0 {
		gap = 300
	}
	pow := math.Pow(10, float64(digits))
	if side == t.OrderSideBuy {
		return Round((sl*pow+gap)/pow, pow)
	}
	return Round((sl*pow-gap)/pow, pow)
}

// CalcTPStop calculates a stop price of the take profit price
func CalcTPStop(side string, tp float64, gap float64, digits int64) float64 {
	if gap == 0 {
		gap = 300
	}
	pow := math.Pow(10, float64(digits))
	if side == t.OrderSideBuy {
		return Round((tp*pow-gap)/pow, pow)
	}
	return Round((tp*pow+gap)/pow, pow)
}

// CalcStopUpperTicker calculates a stop price upper than the ticker price
func CalcStopUpperTicker(tickerPrice float64, gap float64, digits int64) float64 {
	return CalcSLStop(t.OrderSideBuy, tickerPrice, gap, digits)
}

// CalcStopLowerTicker calculates a stop price lower than the ticker price
func CalcStopLowerTicker(tickerPrice float64, gap float64, digits int64) float64 {
	return CalcTPStop(t.OrderSideBuy, tickerPrice, gap, digits)
}

// Reverse returns the opposite side
func Reverse(side string) string {
	if side == t.OrderSideBuy {
		return t.OrderSideSell
	}
	return t.OrderSideBuy
}

// NormalizeDouble rounds a floating-point number to a specified accuracy
func NormalizeDouble(number float64, digits int64) float64 {
	pow := math.Pow(10, float64(digits))
	return math.Round(number*pow) / pow
}

// Round extends math.Round for special usecase
func Round(number float64, pow float64) float64 {
	return math.Round(number*pow) / pow
}

// ContainsString checks the string is in the string slice
func ContainsString(sl []string, v string) bool {
	for _, vv := range sl {
		if vv == v {
			return true
		}
	}
	return false
}

// ConvertTfString converts a timeframe string to a minute integer
func ConvertTfString(timeframe string) int {
	switch timeframe {
	case "5m":
		return 5
	case "10m":
		return 10
	case "15m":
		return 15
	case "30m":
		return 30
	case "1h":
		return 60
	case "4h":
		return 240
	case "1d":
		return 1440
	default:
		return 1
	}
}
